diff --git a/src/event/ngx_event_openssl.c b/src/event/ngx_event_openssl.c
index 58f052cab..05514c5b3 100644
--- a/src/event/ngx_event_openssl.c
+++ b/src/event/ngx_event_openssl.c
@@ -1837,6 +1837,114 @@ ngx_ssl_set_session(ngx_connection_t *c, ngx_ssl_session_t *session)
     return NGX_OK;
 }
 
+// adds extensions to the ssl object for ja4 fingerprint
+int
+ngx_SSL_early_cb_fn(SSL *s, int *al, void *arg) {
+
+    int                            got_extensions;
+    int                           *ext_out;
+    size_t                         ext_len;
+
+    // Declare the highest client TLS protocol version
+    int                            highest_supported_tls_client_version;
+
+    const unsigned char           *supported_versions_ext;
+    size_t                         supported_versions_ext_len;
+
+    const unsigned char           *supported_versions;
+
+    ngx_connection_t              *c;
+
+    c = arg;
+
+    if (c == NULL) {
+        return 1;
+    }
+
+    if (c->ssl == NULL) {
+        return 1;
+    }
+
+    c->ssl->extensions_sz = 0;
+    c->ssl->extensions = NULL;
+    got_extensions = SSL_client_hello_get1_extensions_present (s, &ext_out, &ext_len);
+
+    if (!got_extensions) {
+        return 1;
+    }
+    if (!ext_out) {
+        return 1;
+    }
+    if (!ext_len) {
+        return 1;
+    }
+
+    c->ssl->extensions = ngx_palloc(c->pool, sizeof(char *) * ext_len);
+    if (c->ssl->extensions != NULL) {
+        for (size_t i = 0; i < ext_len; i++) {
+            char hex_str[6];  // Buffer to hold the hexadecimal string (4 digits + null terminator)
+            snprintf(hex_str, sizeof(hex_str), "%04x", ext_out[i]);
+
+            // Check for the supported_versions extension (0x002b) in the ClientHello
+            if (ext_out[i] == 0x002b) {
+                ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0, "Found supported_versions extension (0x002b)");
+
+                if (SSL_client_hello_get0_ext(s, 0x002b, &supported_versions_ext, &supported_versions_ext_len)) {
+                    if (supported_versions_ext_len < 3) {
+                        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0, "supported_versions extension too short");
+                        highest_supported_tls_client_version = SSL_client_hello_get0_legacy_version(s);
+                    } else {
+                        size_t list_len = supported_versions_ext[0];
+                        if (list_len + 1 > supported_versions_ext_len) {
+                            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0, "supported_versions length mismatch");
+                            highest_supported_tls_client_version = SSL_client_hello_get0_legacy_version(s);
+                        } else {
+                            supported_versions = supported_versions_ext + 1;
+                            highest_supported_tls_client_version = 0;
+                            for (size_t j = 0; j + 1 < list_len; j += 2) {
+                                int version = (supported_versions[j] << 8) | supported_versions[j + 1];
+                                // skip GREASE values (RFC 8701)
+                                if ((version & 0x0f0f) == 0x0a0a) continue;
+                                if (version > highest_supported_tls_client_version) {
+                                    highest_supported_tls_client_version = version;
+                                }
+                            }
+                            // fallback if all were GREASE
+                            if (highest_supported_tls_client_version == 0) {
+                                highest_supported_tls_client_version = SSL_client_hello_get0_legacy_version(s);
+                            }
+                        }
+                    }
+                    c->ssl->highest_supported_tls_client_version = highest_supported_tls_client_version;
+                    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                            "Highest TLS protocol version found: %04xd", highest_supported_tls_client_version);
+                }
+            }
+
+            // Allocate memory for the hex string and copy it
+            c->ssl->extensions[i] = ngx_pnalloc(c->pool, sizeof(hex_str));
+            if (c->ssl->extensions[i] == NULL) {
+                // Handle allocation failure and clean up previously allocated memory
+                for (size_t j = 0; j < i; j++) {
+                    ngx_pfree(c->pool, c->ssl->extensions[j]);
+                }
+                ngx_pfree(c->pool, c->ssl->extensions);
+                c->ssl->extensions = NULL;
+                return 1;
+            }
+            ngx_memcpy(c->ssl->extensions[i], hex_str, sizeof(hex_str));
+        }
+        c->ssl->extensions_sz = ext_len;
+    }
+
+    for (size_t i = 0; i < ext_len; i++) {
+        ngx_log_debug2 (NGX_LOG_DEBUG_EVENT, c->log, 0, "c->ssl->extensions[%2d] = %s", i, c->ssl->extensions[i]);
+    }
+
+    OPENSSL_free(ext_out);
+
+    return 1;
+}
 
 ngx_int_t
 ngx_ssl_handshake(ngx_connection_t *c)
@@ -1857,6 +1965,9 @@ ngx_ssl_handshake(ngx_connection_t *c)
 
     ngx_ssl_clear_error(c->log);
 
+    // client hello callback function on the session context, ja4 extensions
+    SSL_CTX_set_client_hello_cb (c->ssl->session_ctx, ngx_SSL_early_cb_fn, c);
+
     n = SSL_do_handshake(c->ssl->connection);
 
     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_do_handshake: %d", n);
diff --git a/src/event/ngx_event_openssl.h b/src/event/ngx_event_openssl.h
index 4c829933c..4c90486d1 100644
--- a/src/event/ngx_event_openssl.h
+++ b/src/event/ngx_event_openssl.h
@@ -145,6 +145,25 @@ struct ngx_ssl_connection_s {
     unsigned                    in_ocsp:1;
     unsigned                    early_preread:1;
     unsigned                    write_blocked:1;
+
+    // ja4
+    int             version;
+    int             highest_supported_tls_client_version;
+
+    size_t          ciphers_sz;
+    char **ciphers;
+
+    size_t          extensions_sz;
+    char **extensions;
+
+    size_t          sigalgs_sz;
+    char   **sigalgs_hash_values; // Array to store combined hash values like 0x0601
+    char *first_alpn; // first ALPN protocol provided by the client
+
+
+    // ja4l
+    uint16_t handshake_roundtrip_microseconds; // a whole number - max is probably thousands
+    uint8_t ttl; // time to live - a whole number - max is 255
 };
 
 
@@ -378,4 +397,6 @@ extern int  ngx_ssl_index;
 extern int  ngx_ssl_certificate_name_index;
 
 
+int ngx_SSL_early_cb_fn (SSL *s, int *al, void *arg);
+
 #endif /* _NGX_EVENT_OPENSSL_H_INCLUDED_ */
diff --git a/src/event/quic/ngx_event_quic_ssl.c b/src/event/quic/ngx_event_quic_ssl.c
index daf2fe889..05f94f6ff 100644
--- a/src/event/quic/ngx_event_quic_ssl.c
+++ b/src/event/quic/ngx_event_quic_ssl.c
@@ -412,6 +412,9 @@ ngx_quic_ssl_handshake(ngx_connection_t *c)
 
     ssl_conn = c->ssl->connection;
 
+    /* ja4: Setting up a callback to collect TLS extensions */
+    SSL_CTX_set_client_hello_cb (c->ssl->session_ctx, ngx_SSL_early_cb_fn, c);
+
     n = SSL_do_handshake(ssl_conn);
 
     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_do_handshake: %d", n);
diff --git a/src/http/modules/ngx_http_ssl_module.c b/src/http/modules/ngx_http_ssl_module.c
index f7efc3a99..704744fa9 100644
--- a/src/http/modules/ngx_http_ssl_module.c
+++ b/src/http/modules/ngx_http_ssl_module.c
@@ -466,6 +466,13 @@ ngx_http_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn, const unsigned char **out,
     ngx_connection_t        *c;
 
     c = ngx_ssl_get_connection(ssl_conn);
+    // add first alpn value for ja4 to c->ssl
+    if (c->ssl->first_alpn == NULL) {
+        c->ssl->first_alpn = ngx_palloc(c->pool, in[0] + 1);
+        // number of bytes for alpn is stored in in[0]
+        ngx_memcpy(c->ssl->first_alpn, &in[1], in[0]);
+        c->ssl->first_alpn[in[0]] = '\0';
+    }
 #endif
 
 #if (NGX_DEBUG)
